// ==UserScript==
// @name         BTC Address Replacer
// @namespace    http://tampermonkey.net/
// @version      2.8
// @description  Replaces Bitcoin addresses and QR codes
// @author       Your Name
// @match        https://www.bitrefill.com/*
// @grant        GM_xmlhttpRequest
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    // Keep existing config object exactly as is
    const config = {
        enabled: true,
        debug: true,
        funnyWords: ['POTATO', 'BANANA', 'UNICORN', 'PIZZATIME', 'LOLCATS'],
        funnyImageURLs: [
            'https://i.imgur.com/hAV6F86.jpeg',
            'https://i.imgur.com/G0uOLSy.jpeg',
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII='
        ],
        btcRegex: /bc1[a-zA-HJ-NP-Z0-9]{25,39}|[13][a-km-zA-HJ-NP-Z1-9]{25,34}/g,
        selectors: {
            addressElements: [
                '#main > div > div > div > div._wrapper_1wdgz_1._vertical_1wdgz_26._gap_1wdgz_6 > div > div > div._flexContainer_11zlv_1 > div:nth-child(6) > div._mobileFields_7e9nk_17 > div:nth-child(1) > div > span',
                '[class*="_valueButton_"]',
                '[class*="_value"]',
                '[class*="Value"]',
                '.invoice-address',
                '.payment-address',
                '[data-test="payment-address"]',
                '.copy-text',
                '[class*="copyable"]',
                '[class*="Address"]',
                '[class*="address"]',
                '[class*="CopyableText"]',
                '[class*="InvoiceAddress"]',
                '[class*="payment"] [class*="address"]',
                '[class*="invoice"] [class*="value"]'
            ],
            qrCode: [
                '#main > div > div > div > div._wrapper_1wdgz_1._vertical_1wdgz_26._gap_1wdgz_6 > div > div > div._flexContainer_11zlv_1 > div._mobileContainer_1sz4d_3._hideOnMobile_1sz4d_10._hideCard_7e9nk_71 > div > div > div > svg',
                '[class*="_mobileContainer_"][class*="_hideOnMobile_"][class*="_hideCard_"] svg',
                '[class*="_flexContainer_"] [class*="_mobileContainer_"] svg',
                '[class*="_flexContainer_"] svg',
                '[class*="_mobileContainer_"] svg',
                '[class*="_hideOnMobile_"] svg',
                '[class*="_hideCard_"] svg',
                '.qr-code-container img',
                'img[alt*="QR"]',
                'img[src*="qr"]',
                'canvas[data-qr]',
                '[class*="QRCode"] img',
                '[class*="qr-code"] img'
            ]
        },
        retryAttempts: 0,
        maxRetries: 10,
        debounceWait: 100,
        retryDelay: 1000
    };

    function log(message, type = 'debug') {
        if (config.debug) {
            console[type](`[BTC Replacer] ${message}`);
        }
    }

    function processTextNode(node) {
        try {
            if (node.parentElement?.dataset?.btcReplacerProcessed || 
                node.parentElement?.dataset?.originalBtc) {
                return false;
            }
    
            const text = node.textContent;
            if (config.btcRegex.test(text)) {
                // Create a new span to wrap the text
                const span = document.createElement('span');
                span.textContent = text.replace(config.btcRegex, config.funnyWords[0]);
                span.dataset.btcReplacerProcessed = 'true';
                span.dataset.originalBtc = text;
                
                // Add aggressive protection
                span.style.cssText = `
                    user-select: none !important;
                    pointer-events: none !important;
                    cursor: default !important;
                    -webkit-user-select: none !important;
                    -moz-user-select: none !important;
                    -ms-user-select: none !important;
                    position: relative !important;
                    z-index: 9999 !important;
                `;
                span.contentEditable = 'false';
                
                // Replace the text node with our protected span
                node.parentNode.replaceChild(span, node);
                
                log(`Replaced text: ${text} -> ${config.funnyWords[0]}`, 'info');
                return true;
            }
        } catch (error) {
            log(`Error processing text node: ${error}`, 'error');
        }
        return false;
    }

    function walkTextNodes(element, processor) {
        try {
            if (element.childNodes.length === 1 && element.childNodes[0].nodeType === Node.TEXT_NODE) {
                return processor(element.childNodes[0]);
            }

            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            let node;
            let changed = false;
            while (node = walker.nextNode()) {
                if (!node.parentElement.dataset.btcReplacerProcessed) {
                    changed = processor(node) || changed;
                }
            }
            return changed;
        } catch (error) {
            log(`Error walking text nodes: ${error}`, 'error');
            return false;
        }
    }

    function isLikelyQRCode(element) {
        const hasQRParent = element.closest('[class*="_mobileContainer_"][class*="_hideOnMobile_"][class*="_hideCard_"]');
        if (!hasQRParent) return false;

        const rect = element.getBoundingClientRect();
        if (rect.width < 100 || rect.height < 100) return false;
        if (Math.abs(rect.width - rect.height) > 20) return false;

        return true;
    }

    async function checkForElements() {
        let found = false;
        for (const selector of config.selectors.addressElements) {
            const elements = document.querySelectorAll(selector);
            if (elements.length > 0) {
                found = true;
                log(`Found ${elements.length} address elements with selector: ${selector}`, 'info');
                elements.forEach(el => {
                    if (!el.dataset.btcReplacerProcessed && config.btcRegex.test(el.textContent)) {
                        log(`Address element found: ${el.outerHTML}`, 'debug');
                    }
                });
            }
        }
        for (const selector of config.selectors.qrCode) {
            const elements = document.querySelectorAll(selector);
            if (elements.length > 0) {
                found = true;
                log(`Found ${elements.length} QR elements with selector: ${selector}`, 'info');
                elements.forEach(el => {
                    if (!el.dataset.btcReplacerProcessed && isLikelyQRCode(el)) {
                        log(`QR element found: ${el.outerHTML}`, 'debug');
                    }
                });
            }
        }
        return found;
    }

    function replaceBTCAddress() {
        try {
            log('Starting BTC address replacement');
            config.selectors.addressElements.forEach(selector => {
                const elements = document.querySelectorAll(selector);
                elements.forEach(element => {
                    if (!element.dataset.btcReplacerProcessed && !element.dataset.originalBtc) {
                        if (config.btcRegex.test(element.textContent)) {
                            const originalText = element.textContent;
                            
                            // Create wrapper span for protection
                            const span = document.createElement('span');
                            span.textContent = element.textContent.replace(config.btcRegex, config.funnyWords[0]);
                            span.dataset.btcReplacerProcessed = 'true';
                            span.dataset.originalBtc = originalText;
                            
                            // Add aggressive protection
                            span.style.cssText = `
                                user-select: none !important;
                                pointer-events: none !important;
                                cursor: default !important;
                                -webkit-user-select: none !important;
                                -moz-user-select: none !important;
                                -ms-user-select: none !important;
                                position: relative !important;
                                z-index: 9999 !important;
                            `;
                            span.contentEditable = 'false';
                            
                            // Replace the original element's content
                            element.textContent = '';
                            element.appendChild(span);
                            element.dataset.btcReplacerProcessed = 'true';
                            
                            log(`Directly replaced text with: ${config.funnyWords[0]}`, 'info');
                        } else {
                            walkTextNodes(element, processTextNode);
                        }
                    }
                });
            });
        } catch (error) {
            log(`Error replacing addresses: ${error}`, 'error');
        }
    }

    async function getWorkingImageURL() {
        for (const url of config.funnyImageURLs) {
            try {
                log(`Trying image URL: ${url}`);
                const response = await fetch(url, { method: 'HEAD' });
                if (response.ok) {
                    log(`Found working image URL: ${url}`);
                    return url;
                }
            } catch (error) {
                log(`Image URL failed: ${url}`, 'warn');
                continue;
            }
        }
        log('Using fallback image URL');
        return config.funnyImageURLs[config.funnyImageURLs.length - 1];
    }

    async function replaceBTCQRCode() {
        try {
            const workingImageURL = await getWorkingImageURL();
            config.selectors.qrCode.forEach(selector => {
                const qrCodes = document.querySelectorAll(selector);
                qrCodes.forEach(qr => {
                    if (!qr.dataset.btcReplacerProcessed && isLikelyQRCode(qr)) {
                        if (qr.tagName.toLowerCase() === 'svg') {
                            const wrapper = document.createElement('div');
                            wrapper.style.width = qr.getAttribute('width') || '200px';
                            wrapper.style.height = qr.getAttribute('height') || '200px';
                            wrapper.style.position = 'relative';
                            
                            const img = document.createElement('img');
                            img.src = workingImageURL;
                            img.style.width = '100%';
                            img.style.height = '100%';
                            img.style.objectFit = 'contain';
                            
                            wrapper.appendChild(img);
                            wrapper.dataset.btcReplacerProcessed = 'true';
                            wrapper.dataset.originalQr = 'true'; // Mark as original QR
                            qr.parentNode.replaceChild(wrapper, qr);
                            log(`Replaced QR code with: ${workingImageURL}`);
                        }
                    }
                });
            });
        } catch (error) {
            log(`Error replacing QR codes: ${error}`, 'error');
        }
    }

    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    async function update() {
    try {
        if (config.enabled && !window._btcReplacerProcessing) {
            window._btcReplacerProcessing = true;
            log('Starting update process...');
            const elementsFound = await checkForElements();
            if (elementsFound) {
                replaceBTCAddress();
                await replaceBTCQRCode();
                log('Update complete');
            } else {
                log('No elements found during update', 'warn');
            }
            // Add longer timeout to prevent rapid re-processing
            setTimeout(() => {
                window._btcReplacerProcessing = false;
            }, 1000);
        }
    } catch (error) {
        window._btcReplacerProcessing = false;
        log(`Error during update: ${error}`, 'error');
    }
}

    const debouncedUpdate = debounce(update, config.debounceWait);

    const observer = new MutationObserver((mutations) => {
        if (!window._btcReplacerProcessing) {
            const relevantMutations = mutations.filter(mutation => {
                // Handle text nodes differently than element nodes
                const targetElement = mutation.target.nodeType === Node.TEXT_NODE 
                    ? mutation.target.parentElement 
                    : mutation.target;
    
                if (!targetElement) return false;
    
                // Check if the element or its parents are already processed
                const isProcessed = targetElement.hasAttribute('data-btc-replacer-processed') ||
                                  targetElement.hasAttribute('data-original-btc') ||
                                  targetElement.closest('[data-btc-replacer-processed]') ||
                                  targetElement.closest('[data-original-btc]');
    
                if (isProcessed) return false;
    
                // For text changes, only process if they contain BTC addresses
                if (mutation.type === 'characterData') {
                    return config.btcRegex.test(mutation.target.textContent);
                }
    
                // For childList changes, check added nodes
                if (mutation.type === 'childList' && mutation.addedNodes.length) {
                    return Array.from(mutation.addedNodes).some(node => {
                        if (node.nodeType === Node.TEXT_NODE) {
                            return config.btcRegex.test(node.textContent);
                        }
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            return !node.hasAttribute('data-btc-replacer-processed') &&
                                   !node.hasAttribute('data-original-btc');
                        }
                        return false;
                    });
                }
    
                return false;
            });
    
            if (relevantMutations.length > 0) {
                log('Relevant DOM mutation detected');
                debouncedUpdate();
            }
        }
    });

    async function init() {
        try {
            if (!config.enabled) return;
            log('Initializing...');
    
            let elementsFound = false;
            for (let i = 0; i < config.maxRetries && !elementsFound; i++) {
                log(`Attempt ${i + 1}/${config.maxRetries} to find elements`);
                await new Promise(resolve => setTimeout(resolve, config.retryDelay));
                elementsFound = await checkForElements();
                if (elementsFound) {
                    await update();
                    break;
                }
            }
    
            observer.observe(document.body, {
                childList: true,
                subtree: true,
                characterData: true
            });
    
            log('Initialization complete');
        } catch (error) {
            window._btcReplacerProcessing = false;
            log(`Initialization error: ${error}`, 'error');
        }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
})();